/*
	This brief code for internet connection is obtained and modified from the Microsoft
	website for the term project of NTUST ME2008303 class, 2019.
	Author: Yu-Hsuan Su
			National Taiwan University of Science and Technology
			Department of Mechanical Engineering
*/

#include <stdio.h>
#include "inet.h"
#include <time.h>
#pragma warning(disable:4996)

#define SERVER
#define DEBUG

int __cdecl main(int argc, char **argv)
{

#ifdef SERVER

	int states=1;
	char str[512] = "Waiting for an player .~.~.~. \n";

	printf("%s", str); server_listen();// waiting for client to connect

	srand(time(NULL));
	int player = 2;
	int card_num = 52;
	int round = card_num / player;
	int card[2][28];
	int card_all[54];
	char color[4][5] = { "黑桃","紅心","方塊","梅花" };
	char point[13][3] = { "A","2","3","4","5","6","7","8","9","T","J","Q","K" };//
	int play_card;


	for (int i = 0; i < card_num; i++) card_all[i] = i;
	for (int j = 0; j < round; j++) { //發牌 X 回
		for (int i = 0; i < player; i++) {
			play_card = rand() % card_num;
			card[i][j] = card_all[play_card];
			card_all[play_card] = card_all[card_num - 1];
			card_num--;
		}
	}
	for (int i = 0; i < player; i++) //從玩家1開始依照大小排手牌。
	{
		for (int k = 1; k < round; k++)//總共需要檢查的次數
		{
			for (int j = 0; j < round - k; j++)//[玩家I][第J張牌] 第1回向後檢查25次，第2回向後檢查24次....
			{
				if (card[i][j] > card[i][j + 1])//如果第X張牌數字>X+1(後方)那麼將兩者互換。
				{
					int temp = card[i][j];
					card[i][j] = card[i][j + 1];
					card[i][j + 1] = temp;
				}
			}
		}
	}
	
	
	//給玩家2
	char plar2Card[256] = "";
	for (int j = 0; j < round; j++)
	{
		if (card[1][j] == 52 || card[1][j] == 53)//沒有花色的鬼牌
		{
			printf("JOKER");
		}
		else {
			strcat(plar2Card, color[card[1][j] % 4]);
			strcat(plar2Card, "_");
			strcat(plar2Card, point[card[1][j] / 4]);
			strcat(plar2Card, " , ");
		}
	}


	do {
		recv_str();
		printf(" ##~~遊戲開始~~## \n\n 以下是你的牌組 <Jack> : \n");
		//將號碼對應的撲克牌列出
		for (int j = 0; j < round; j++)
		{
			if (card[0][j] == 52 || card[0][j] == 53)//沒有花色的鬼牌
			{
				printf("JOKER");
			}
			else {
				printf("%s_", color[card[0][j] % 4]);
				printf("%s", point[card[0][j] / 4]);
			}
			if (j != round - 1)printf(" , ");
			else printf("\n\n");

		}

		

		printf("Jack 請按下 ENTER ，丟棄重複的牌。 \n");
		printf(" <Jack> : "); fgets(str, sizeof(str), stdin);// prompt for input

		// To end connection, put @ as the first character
		if (str[0] == '@') return 0;
		// remove the newline character obtained by fgets()
		int i = 0;  while (str[i] != '\n') i++; str[i] = '\0';

		send_str(plar2Card);
		states = 2;

	} while (states==1);

	int jackCard[100];
	int jackI = 0;

	//發牌之後，顯示剩餘不重複
	do {
		
		//printf("now stage 2 ");
		/*for (int j = 0; j < round ; j++)
		{
			printf("%d  ", card[0][j]);
		}*/

		int throwJ=0;
		while(throwJ < round)
		{
			//如果比到最後一個
			if ((throwJ) == 25)
			{
				
				//printf("~~~~~最後一位~~~~~ %d  jackI--%d \n", card[0][throwJ], jackI);
				jackCard[jackI] = card[0][throwJ];
				throwJ++;
			}
			//這裡bug
			//printf("%d 回合 第一 %d == 第二%d \ ",j, card[0][j], card[0][j + 1]);
			//printf("檢查:  %d \n", card[0][throwJ]);
			else if ((card[0][throwJ + 1] /4 == card[0][throwJ] /4 ) && (card[0][throwJ +1] - card[0][throwJ] <=3))
			{
				throwJ+=2;
			}
			else {
				jackCard[jackI] = card[0][throwJ];
				//printf("%d != %d \n", card[0][throwJ], card[0][throwJ + 1]);
				jackI++;
				throwJ++;
			}
			//printf("接著檢查:  %d \n", card[0][throwJ]);
			//printf("throwJ是%d \n", throwJ);
		}

		printf(" Jack 剩下 : \n" );
		for (int j = 0; j <= jackI; j++)
		{

			//printf(" %d,-", jackCard[j]);
			printf("%s_", color[jackCard[j] % 4]);
			printf("%s  ", point[jackCard[j] / 4]);
		}


		recv_str();
		states = 3;
	} while (states==2);

	// end connection
	inet_shutdown();
#endif // SERVER
}
